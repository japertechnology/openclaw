# OpenClaw GitHub Mode Implementation Plan

## Objective

Implement the new GitHub Runtime Plane described in `.GITHUB-MODE.md` without regressing the Installed Runtime Plane, while enforcing security management through standard GitHub controls (GitHub Secrets, Environments, branch protection, required reviewers, least-privilege `GITHUB_TOKEN`, OIDC, and pinned actions).

---

## Guiding Constraints

1. **No installed-runtime regressions**
   - Existing local/daemon/gateway/channel behaviors remain unchanged.
2. **Core-path reuse first**
   - Reuse `src/auto-reply/reply`, `src/agents/pi-embedded-runner`, and existing tool-policy flow.
3. **GitHub-native security management required**
   - Secret/API key handling must use GitHub-native mechanisms (no ad-hoc secret files or custom key vaults in repo).
4. **Parity is explicit and measurable**
   - Every feature is classified as `native`, `adapter`, `emulated`, or `installed-only`.

---

## Step-by-Step Implementation Plan

## Phase 0 - Baseline, Design Locks, and Risk Control

### Step 0.1 - Freeze baseline behavior and define non-regression checks

- Capture current installed-runtime behavior with baseline tests and smoke checks.
- Define a "must pass" regression suite for installed runtime paths.
- Record baseline in implementation notes for future parity comparisons.

### Step 0.2 - Create architecture decision records for runtime split

- Add ADR(s) documenting:
  - installed runtime boundaries
  - GitHub runtime overlay boundaries
  - shared core modules and adapter seams
- Include explicit rejection of any design that entangles installed runtime startup with GitHub-only configuration.

### Step 0.3 - Define threat model for GitHub Runtime Plane

- Document trust boundaries:
  - push from trusted branches
  - internal PRs
  - forks/untrusted PRs
  - issue/PR comment command triggers
- Enumerate abuse cases (secret exfiltration, privilege escalation, command injection, bot branch misuse).
- Map mitigations to concrete GitHub controls.

---

## Phase 1 - Runtime Contract Scaffolding

### Step 1.1 - Add `runtime/github/` contracts

Create initial contract files:

- `runtime/github/manifest.schema.json`
- `runtime/github/runtime-manifest.json`
- `runtime/github/adapter-contracts.json`
- `runtime/github/command-policy.json`
- `runtime/github/trust-levels.json`

These should define trigger types, allowed command sets, adapter availability, and trust-level policy.

### Step 1.2 - Add parity matrix and validation

- Create `runtime/github/parity-matrix.json` with initial classifications for major subsystems.
- Add a parity validator script that:
  - validates schema
  - requires ownership/notes for `installed-only`
  - computes a parity summary score artifact.

### Step 1.3 - Add GitHub-mode capability flags

- Introduce runtime flags/config for GitHub mode adapters.
- Ensure defaults preserve installed runtime behavior.
- Add tests asserting no GitHub-mode codepath is activated in installed runtime unless explicitly configured.

---

## Phase 2 - Secure Execution Foundation (GitHub-native controls)

### Step 2.1 - Standardize API key and secret handling using GitHub features

- Define a key inventory table in docs for each required secret:
  - secret name
  - environment scope (`dev`, `staging`, `prod`)
  - rotation owner
  - expiry/rotation cadence
- Store runtime secrets only in:
  - repository/organization secrets
  - environment secrets
- Use GitHub Variables for non-sensitive config.
- Explicitly ban secrets in repo files, workflow inputs, cache keys, artifacts, and logs.

### Step 2.2 - Enforce environment-scoped secret access

- Configure GitHub Environments:
  - `github-mode-dev`
  - `github-mode-staging`
  - `github-mode-prod`
- Add required reviewers for staging/prod environments.
- Restrict environment branch/tag deployment rules.
- Gate promotion workflows to environment approval checks.

### Step 2.3 - Harden workflow permissions

- Add explicit `permissions:` blocks in every workflow with least privilege.
- Split workflows by trust level:
  - untrusted checks: read-only token, no secrets
  - trusted command/prod flows: narrowly scoped write permissions
- Disable broad defaults and avoid `contents: write` where unnecessary.

### Step 2.4 - Adopt OIDC for cloud credentials where applicable

- Replace static cloud credentials with GitHub OIDC federation.
- Bind OIDC audiences and claims to specific repos, environments, and branches.
- Keep cloud-side policies least privilege and environment-specific.

### Step 2.5 - Pin and verify third-party actions

- Pin all third-party actions by full commit SHA.
- Add a workflow linter check that fails on unpinned actions.
- Track action updates via periodic dependency workflow.

### Step 2.6 - Add command authorization and actor trust policy

- Define trusted actor policy for comment/dispatch commands:
  - org members/teams allowlist
  - maintainer role checks
  - optional label-based opt-in
- Enforce policy before any privileged adapter/tool execution.
- For untrusted actors, allow only non-secret, read-only, constrained operations.

---

## Phase 3 - Core GitHub Workflows (Validation + Simulation + Cost)

### Step 3.1 - Implement validation stack

Add workflows:

- `github-mode-build.yml`
- `github-mode-check.yml`
- `github-mode-test.yml`

Each workflow should:

- run in untrusted-safe mode for PRs from forks
- block secret access in untrusted contexts
- upload deterministic artifacts and summaries.

### Step 3.2 - Implement policy and route simulation workflows

Add:

- `github-mode-policy.yml`
- `github-mode-route-sim.yml`

Requirements:

- execute route and tool-policy checks against contracts in `routing/`, `policies/`, `agents/`
- produce machine-readable reports and markdown summaries
- fail on policy drift or unsafe contract expansion.

### Step 3.3 - Implement eval and cost workflows

Add:

- `github-mode-eval-tier0.yml`
- `github-mode-cost.yml`

Requirements:

- run fixture/replay-driven evaluations from `datasets/` and `eval/`
- emit scorecards, regressions, and budget deltas
- enforce threshold gates for promotion eligibility.

---

## Phase 4 - Conversational Runtime Workflows and Bot PR Loop

### Step 4.1 - Implement command workflow

Add `github-mode-command.yml` to handle `explain`, `refactor`, `test`, `diagram`.

Execution policy:

- parse command source (issue/PR comment or workflow dispatch)
- evaluate actor trust + context trust
- route to safe adapter set based on trust level.

### Step 4.2 - Implement constrained agent-run workflow

Add `github-mode-agent-run.yml`:

- run core orchestration path with GitHub adapters
- enforce tool-policy contracts from `runtime/github/command-policy.json`
- post signed, traceable summary outputs.

### Step 4.3 - Implement bot PR workflow

Add `github-mode-bot-pr.yml`:

- create branch outputs for approved commands
- open PRs with provenance metadata (input command, commit SHA, policy version)
- ensure no direct writes to protected branches.

---

## Phase 5 - Promotion, Attestation, and Incident Operations

### Step 5.1 - Implement promotion workflows

Add:

- `github-mode-promote-dev.yml`
- `github-mode-promote-staging.yml`
- `github-mode-promote-prod.yml`

Requirements:

- environment protections and approvals required
- promotion blocked unless validation/eval/cost/policy checks are green
- immutable artifact references in promotion records.

### Step 5.2 - Implement attestation generation and verification

- Generate attestations in `attestations/` containing required fields:
  - commit/environment/policy/routing/agent revisions
  - model IDs, dataset hashes, eval summary, budget caps, approvers, timestamp
- Add verification step to confirm attestation completeness and tamper-evidence.

### Step 5.3 - Implement drift and incident workflows

Add:

- `github-mode-drift.yml`
- `github-mode-incident.yml`

Requirements:

- scheduled drift checks over policy/routes/evals/cost envelopes
- auto-create issues with severity labels and evidence links
- optional escalation to promotion lock when severe drift detected.

---

## Phase 6 - Adapter and Emulation Expansion

### Step 6.1 - Build adapter library for GitHub-safe tools

- Implement adapters for:
  - filesystem patch planning
  - docs generation
  - route simulation
  - replayed inbound event streams
- Keep adapters explicitly separate from installed-only tooling.

### Step 6.2 - Build emulation harnesses

- Add replay/mocks for channel events and memory stores.
- Define fidelity score per emulated subsystem.
- Feed outcomes into parity matrix updates.

### Step 6.3 - Shrink installed-only surface deliberately

- Identify installed-only capabilities that can move to `adapter` or `emulated`.
- Require threat-model + parity + test updates for each migration.

---

## Phase 7 - Observability, Compliance, and Ongoing Governance

### Step 7.1 - Add runtime observability

- Standardize workflow summary and artifact schemas.
- Emit metrics for:
  - parity coverage
  - workflow success/flakiness
  - bot PR throughput
  - policy violation frequency
  - promotion lead/rollback time.

### Step 7.2 - Add compliance checks for security controls

Create mandatory checks that fail when:

- workflow permissions are over-broad
- third-party actions are not SHA-pinned
- protected workflows expose secrets in untrusted triggers
- environment-protected promotions are bypassed.

### Step 7.3 - Define rotation and incident playbooks

- Add operational runbooks for:
  - API key/secret rotation (GitHub Secrets + Environment Secrets)
  - emergency secret revocation
  - compromised workflow token response
  - attestation audit and rollback process.

---

## Security Requirements Checklist (must be true before rollout)

1. All API keys managed through GitHub Secrets/Environment Secrets only.
2. No secrets available to fork PR workflows.
3. All privileged workflows require trusted actor and/or environment approval.
4. All third-party actions pinned by commit SHA.
5. `GITHUB_TOKEN` permissions explicitly least-privilege per workflow/job.
6. OIDC used instead of long-lived cloud credentials where possible.
7. Protected branches cannot be written directly by GitHub mode bots.
8. Promotion requires successful gates + recorded attestation.
9. Logs/artifacts are scrubbed to prevent secret leakage.
10. Security lint checks enforce the above continuously.

---

## Delivery Milestones

- **M1:** Contract scaffolding + parity matrix + threat model + baseline tests
- **M2:** Security foundation complete (secrets/environments/permissions/OIDC/action pinning)
- **M3:** Validation/policy/route/eval/cost workflows live
- **M4:** Command + agent-run + bot PR workflows live
- **M5:** Promotion + attestation + drift/incident workflows live
- **M6:** Expanded adapters/emulation + parity score reporting

---

## Definition of Done for Implementation

GitHub Mode is considered implemented when:

1. Installed runtime behavior remains unchanged under baseline regression checks.
2. GitHub Runtime Plane executes high-value orchestration/eval/policy workflows using shared core paths.
3. Security is fully managed through normal GitHub controls (Secrets, Environments, approvals, permissions, OIDC, branch protection, SHA-pinned actions).
4. Promotion and incident handling are approval-gated and backed by attestations.
5. Parity matrix is maintained and shows measurable progress over time.
