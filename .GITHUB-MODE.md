# OpenClaw GitHub Mode

## Core Clarification

This design has two distinct runtime planes:

1. **Installed Runtime Plane (unchanged):** PC/macOS/Linux run OpenClaw the normal way when installed.
2. **GitHub Runtime Plane (new):** OpenClaw runs inside GitHub workflows from repository commits.

The main objective is to deliver **as much OpenClaw functionality as possible in GitHub Runtime Plane** without breaking the installed runtime model.

An equally important objective is **experience convergence**: installed workflows (workspace semantics, CLI behavior, and web/gateway control surfaces) should map directly to GitHub workflows so operators can move between planes with minimal cognitive switching.

---

## 1) Product Model

### 1.1 Installed Runtime Plane (existing behavior)

Keep current behavior and operations:

- local/daemon usage
- always-on gateway behavior
- channel integrations requiring persistent sessions
- device capabilities (camera/mic/location/screen/node features)
- existing onboarding and platform app flows

No regressions or behavioral coupling to GitHub mode are allowed.

### 1.2 GitHub Runtime Plane (new behavior)

Run OpenClaw from checked-out commits in GitHub Actions and GitHub Environments:

- PR checks
- on-demand command workflows
- scheduled monitoring/eval workflows
- promotion workflows with approvals
- bot PR generation

This is a repo-executed runtime, not a package install runtime.

---

## 2) Goal: Maximum Functional Coverage in GitHub Mode

GitHub mode should not be a tiny lint/eval wrapper. It should run a large subset of real runtime behavior:

- real orchestration path (`src/auto-reply/reply`)
- real agent loop (`src/agents/pi-embedded-runner`)
- real tool policy gates (`src/agents/tools`, `src/agents/pi-tools.ts`)
- route/policy/profile behavior contracts
- durable outputs (PRs, comments, attestations, docs artifacts)

Use the same core code paths, with GitHub-specific adapters where host constraints exist.

### 2.1 Experience convergence targets

Converge installed and GitHub experiences on:

- shared command vocabulary and intent model (CLI, chat commands, workflow dispatch)
- equivalent run visibility (logs, summaries, artifacts, and policy decisions)
- compatible workspace contracts (routing/policies/agents/eval) and revision semantics
- predictable promotion and incident handling across both planes

When constraints prevent exact parity, document explicit differences and preserve the same mental model.

---

## 3) Capability Targets

### 3.1 Target A: Full in GitHub

Implement fully in GitHub mode:

- behavior contract validation (`routing/`, `policies/`, `agents/`)
- evaluation tiers and regression suites (`datasets/`, `eval/`)
- route simulation and policy linting
- model/tool run execution for offline-safe tool sets
- cost/latency projections
- explain/refactor/test generation as bot PRs
- promotion attestations (`attestations/`)
- drift monitoring and incident issue creation

### 3.2 Target B: High-fidelity emulation in GitHub

Emulate production behavior where persistence is unavailable:

- inbound events via replay fixtures
- channel events via adapters/mocks/replay streams
- memory behavior via test stores and fixture corpora
- gateway interaction via ephemeral harness processes

### 3.3 Target C: Installed-only (explicit boundary)

Remain installed-runtime only unless future infrastructure changes:

- long-lived messaging sessions requiring persistent sockets/processes
- hardware-bound node actions (camera, mic, direct device control)
- OS-level local UX and app integrations that need resident processes

---

## 4) Architecture Split

### 4.1 Installed Runtime Architecture (unchanged)

Existing OpenClaw spine remains:

1. `src/auto-reply/reply`
2. `src/agents/pi-embedded-runner`
3. `src/agents/tools` and `src/agents/pi-tools.ts`
4. `src/routing` + `src/channels` + `src/gateway`

### 4.2 GitHub Runtime Architecture (new overlay)

Add a GitHub runtime overlay that reuses core runtime modules:

- **Ingress**
  - issue comments, PR comments, workflow dispatch, scheduled triggers
- **Runtime**
  - same core orchestration + runner paths
- **Adapters**
  - GitHub-safe tool adapters for filesystem patching, docs generation, route/policy simulation
- **Egress**
  - check results, workflow summaries, issue comments, bot branches/PRs, artifacts, attestations

---

## 5) Repository Contracts for GitHub Mode

Use these contract directories as control surface:

- `routing/`: route profiles, safe-mode routes, canary rules
- `policies/`: safety rules, tool permission contracts
- `agents/`: agent profile and tool scope definitions
- `datasets/`: eval fixtures, red-team suites, golden outputs
- `eval/`: scoring configs, replay controls, thresholds
- `attestations/`: promotion manifests with immutable evidence
- `docs/ai/`: durable generated explanations/diagrams
- `runtime/github/` (new): GitHub mode manifest and execution contracts

---

## 6) GitHub Workflow Portfolio (Max Functionality)

### 6.1 Validation and quality

- `github-mode-build.yml`
- `github-mode-check.yml`
- `github-mode-test.yml`
- `github-mode-eval-tier0.yml`
- `github-mode-policy.yml`
- `github-mode-route-sim.yml`
- `github-mode-cost.yml`

### 6.2 Conversational runtime workflows

- `github-mode-command.yml`
  - handles commands like explain/refactor/test/diagram
- `github-mode-agent-run.yml`
  - runs constrained agent tasks and posts results
- `github-mode-bot-pr.yml`
  - writes outputs to branch + opens PR

### 6.3 Promotion and operations

- `github-mode-promote-dev.yml`
- `github-mode-promote-staging.yml`
- `github-mode-promote-prod.yml`
- `github-mode-drift.yml`
- `github-mode-incident.yml`

---

## 7) Functional Parity Strategy for GitHub Mode

### 7.1 Parity principle

For every installed runtime feature, classify:

- `native` (runs as-is in GitHub mode)
- `adapter` (runs via GitHub adapter)
- `emulated` (runs via replay/mock harness)
- `installed-only` (explicitly excluded)

Track this in:

- `runtime/github/parity-matrix.json`

### 7.2 First parity priorities

Highest-value parity first:

1. orchestration and tool policy flow
2. route and policy behavior
3. eval and regression behavior
4. cost/safety evidence production
5. conversational docs/test/refactor PR workflows

---

## 8) Security Model

### 8.1 Installed runtimes

No behavioral regression from current security posture.

### 8.2 GitHub runtime

- no direct writes to `main`
- privileged commands gated to trusted actors
- no secrets in untrusted PR contexts
- least-privilege token permissions
- third-party actions pinned by commit SHA
- untrusted execution uses restricted adapters only

---

## 9) Promotion and Attestation

All staging/prod promotions (GitHub mode or installed-mode control actions) produce attestations containing:

- `commit_sha`
- `environment`
- `policy_revision`
- `routing_revision`
- `agent_revision`
- `model_ids`
- `dataset_hashes`
- `eval_summary`
- `budget_caps`
- `approvers`
- `promoted_at_utc`

This ensures one audit trail across both runtime planes.

---

## 10) Implementation Phases

### Phase 1: Correct split and scaffolding

- freeze installed runtime behavior as baseline
- create `runtime/github/` contracts
- add parity matrix schema and initial entries

### Phase 2: High-value GitHub functionality

- add conversational command workflows
- add bot PR generation workflows
- add route/policy/eval/cost check stack

### Phase 3: Promotion and incident maturity

- wire dev/staging/prod promotions with approvals
- generate attestations for every promotion
- add drift and incident workflows

### Phase 4: Deep parity expansion

- add more adapters and emulation harnesses
- shrink installed-only surface where feasible
- publish parity score by subsystem

---

## 11) Success Metrics

### 11.1 Split correctness

- installed runtime functionality unchanged
- zero forced dependency on GitHub mode for normal installed operation

### 11.2 GitHub functionality growth

- percentage of features in `native` + `adapter` + `emulated`
- number of useful repo commands served by GitHub runtime
- bot PR throughput and acceptance rate
- eval/policy/cost gate coverage

### 11.3 Governance quality

- promotion lead time
- rollback time
- check flakiness
- reproducibility from commit + artifacts

---

## 12) Definition of Done

This initiative is done when:

1. Installed PC/macOS/Linux runtimes continue to run normally as installed.
2. GitHub runtime can execute a high-functionality subset of OpenClaw using core runtime paths.
3. GitHub mode can explain, evaluate, simulate, and propose changes as durable PR artifacts.
4. Promotions and incidents are governed through approvals + attestations.
5. Functional parity is measured and improves over time via a maintained parity matrix.

This delivers the exact split: installed runtimes remain normal, GitHub runtime becomes highly capable.
