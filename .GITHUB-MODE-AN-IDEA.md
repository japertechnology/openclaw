# OpenClaw GitHub Mode: An Idea

OpenClaw GitHub Mode imagines GitHub as a second runtime plane for OpenClaw: not a toy wrapper, but a real execution environment where core intelligence runs directly from repository commits.

The north star is **experience convergence**: the installed experience (agent workspace, web control surface, CLI workflows, and operational ergonomics) and the GitHub experience should feel like the same product with different execution hosts.

In this model, OpenClaw keeps its installed runtime exactly as-is for always-on channels, local device integrations, and long-lived sessions. GitHub Mode adds a parallel, repo-native runtime for pull requests, issue commands, scheduled evaluations, policy checks, promotion gates, and bot-authored improvements.

The magic is parity. Instead of duplicating logic, GitHub Mode reuses OpenClaw’s existing orchestration, routing, policy, and agent loops—then layers adapters where GitHub has constraints (ephemeral jobs, restricted secrets, no persistent sockets). The result is high-fidelity behavior in CI: route simulations, safety contract validation, eval tiers, cost/latency projections, drift detection, and durable evidence artifacts.

Parity is not only for backend logic. It also applies to operator workflows: command vocabulary, policy visibility, run traces, diagnostics, and evidence should map cleanly between installed and GitHub runtimes so users do not have to relearn OpenClaw per surface.

This creates a living control surface in version control:

- `routing/` defines behavior paths
- `policies/` encodes safety boundaries
- `agents/` describes profile/tool scope
- `datasets/` and `eval/` measure regression and quality
- `attestations/` stores promotion evidence

The bigger vision is collaborative reliability at software speed. Every change can be challenged, replayed, scored, and explained before it reaches production. Every promotion can carry cryptographic-style provenance. Every incident can open itself with context.

OpenClaw GitHub Mode is the idea that CI is not just where code is checked—it is where operational intelligence is practiced, proven, and continuously improved.
