# OpenClaw GitHub Mode Implementation Plan

## Objective

Implement the new GitHub Runtime Plane described in `.GITHUB-MODE.md` without regressing the Installed Runtime Plane, while enforcing security management through standard GitHub controls (GitHub Secrets, Environments, branch protection, required reviewers, least-privilege `GITHUB_TOKEN`, OIDC, and pinned actions).

---

## Guiding Constraints

1. **No installed-runtime regressions**
   - Existing local/daemon/gateway/channel behaviors remain unchanged.
2. **Core-path reuse first**
   - Reuse `src/auto-reply/reply`, `src/agents/pi-embedded-runner`, and existing tool-policy flow.
3. **GitHub-native security management required**
   - Secret/API key handling must use GitHub-native mechanisms (no ad-hoc secret files or custom key vaults in repo).
4. **Parity is explicit and measurable**
   - Every feature is classified as `native`, `adapter`, `emulated`, or `installed-only`.
5. **Experience convergence is intentional**
   - GitHub workflows should mirror installed workspace and control-surface ergonomics wherever host constraints allow.
6. **Multi-entity collaboration is mandatory**
   - GitHub users must be able to template, configure, and run multiple OpenClaw entities in their own account and have those entities communicate safely.

---

## Step-by-Step Implementation Plan

## Phase 0 - Baseline, Design Locks, and Risk Control

### Step 0.1 - Freeze baseline behavior and define non-regression checks

- Capture current installed-runtime behavior with baseline tests and smoke checks.
- Define a "must pass" regression suite for installed runtime paths.
- Record baseline in implementation notes for future parity comparisons.

### Step 0.2 - Create architecture decision records for runtime split

- Add ADR(s) documenting:
  - installed runtime boundaries
  - GitHub runtime overlay boundaries
  - shared core modules and adapter seams
- Include explicit rejection of any design that entangles installed runtime startup with GitHub-only configuration.

### Step 0.3 - Define threat model for GitHub Runtime Plane

- Document trust boundaries:
  - push from trusted branches
  - internal PRs
  - forks/untrusted PRs
  - issue/PR comment command triggers
- Enumerate abuse cases (secret exfiltration, privilege escalation, command injection, bot branch misuse).
- Map mitigations to concrete GitHub controls.

---

## Phase 1 - Runtime Contract Scaffolding

### Step 1.1 - Add `runtime/github/` contracts

Create initial contract files:

- `runtime/github/manifest.schema.json`
- `runtime/github/runtime-manifest.json`
- `runtime/github/adapter-contracts.json`
- `runtime/github/command-policy.json`
- `runtime/github/trust-levels.json`
- `runtime/github/entity-manifest.schema.json`
- `runtime/github/collaboration-policy.schema.json`
- `runtime/github/collaboration-envelope.schema.json`

These should define trigger types, allowed command sets, adapter availability, and trust-level policy.

Entity/collaboration contracts must additionally define:

- entity identity and role
- allowed peer entities
- allowed collaboration intents/channels
- required per-message metadata and signature expectations

### Step 1.2 - Add parity matrix and validation

- Create `runtime/github/parity-matrix.json` with initial classifications for major subsystems.
- Add a parity validator script that:
  - validates schema
  - requires ownership/notes for `installed-only`
  - computes a parity summary score artifact.

### Step 1.3 - Add GitHub-mode capability flags

- Introduce runtime flags/config for GitHub mode adapters.
- Ensure defaults preserve installed runtime behavior.
- Add tests asserting no GitHub-mode codepath is activated in installed runtime unless explicitly configured.

### Step 1.4 - Define workspace/control-surface convergence map

- Document how installed workspace primitives map to GitHub primitives:
  - local agent workspace -> repo contract directories + workflow artifacts
  - CLI commands -> workflow dispatch/comment command intents
  - web/gateway run view -> workflow summary + artifact + attestation view
- Add a machine-readable mapping file under `runtime/github/` and fail CI on unmapped high-value installed workflows.

### Step 1.5 - Define template and bootstrap baseline for entity repos

- Create a template baseline spec for repositories generated in user/org accounts.
- Require baseline assets:
  - issue forms
  - PR templates
  - labels
  - CODEOWNERS
  - branch protection expectations
  - default workflows and environment placeholders
- Add a validator that checks new/templated entity repos are bootstrap-complete before collaboration workflows are enabled.

---

## Phase 2 - Secure Execution Foundation (GitHub-native controls)

### Step 2.1 - Standardize API key and secret handling using GitHub features

- Define a key inventory table in docs for each required secret:
  - secret name
  - environment scope (`dev`, `staging`, `prod`)
  - rotation owner
  - expiry/rotation cadence
- Store runtime secrets only in:
  - repository/organization secrets
  - environment secrets
- Use GitHub Variables for non-sensitive config.
- Explicitly ban secrets in repo files, workflow inputs, cache keys, artifacts, and logs.

### Step 2.2 - Enforce environment-scoped secret access

- Configure GitHub Environments:
  - `github-mode-dev`
  - `github-mode-staging`
  - `github-mode-prod`
- Add required reviewers for staging/prod environments.
- Restrict environment branch/tag deployment rules.
- Gate promotion workflows to environment approval checks.

### Step 2.3 - Harden workflow permissions

- Add explicit `permissions:` blocks in every workflow with least privilege.
- Split workflows by trust level:
  - untrusted checks: read-only token, no secrets
  - trusted command/prod flows: narrowly scoped write permissions
- Disable broad defaults and avoid `contents: write` where unnecessary.

### Step 2.4 - Adopt OIDC for cloud credentials where applicable

- Replace static cloud credentials with GitHub OIDC federation.
- Bind OIDC audiences and claims to specific repos, environments, and branches.
- Keep cloud-side policies least privilege and environment-specific.

### Step 2.5 - Pin and verify third-party actions

- Pin all third-party actions by full commit SHA.
- Add a workflow linter check that fails on unpinned actions.
- Track action updates via periodic dependency workflow.

### Step 2.6 - Add command authorization and actor trust policy

- Define trusted actor policy for comment/dispatch commands:
  - org members/teams allowlist
  - maintainer role checks
  - optional label-based opt-in
- Enforce policy before any privileged adapter/tool execution.
- For untrusted actors, allow only non-secret, read-only, constrained operations.

---

## Phase 3 - Core GitHub Workflows (Validation + Simulation + Cost)

### Step 3.1 - Implement validation stack

Add workflows:

- `github-mode-build.yml`
- `github-mode-check.yml`
- `github-mode-test.yml`

Each workflow should:

- run in untrusted-safe mode for PRs from forks
- block secret access in untrusted contexts
- upload deterministic artifacts and summaries.

### Step 3.2 - Implement policy and route simulation workflows

Add:

- `github-mode-policy.yml`
- `github-mode-route-sim.yml`

Requirements:

- execute route and tool-policy checks against contracts in `routing/`, `policies/`, `agents/`
- produce machine-readable reports and markdown summaries
- fail on policy drift or unsafe contract expansion.

### Step 3.3 - Implement eval and cost workflows

Add:

- `github-mode-eval-tier0.yml`
- `github-mode-cost.yml`

Requirements:

- run fixture/replay-driven evaluations from `datasets/` and `eval/`
- emit scorecards, regressions, and budget deltas
- enforce threshold gates for promotion eligibility.

### Step 3.4 - Add template drift and migration workflow

Add:

- `github-mode-sync-templates.yml`

Requirements:

- detect drift from the canonical GitHub mode template baseline
- produce migration PRs or explicit migration guidance
- block collaboration enablement when required template controls are missing.

---

## Phase 4 - Conversational Runtime Workflows and Bot PR Loop

### Step 4.1 - Implement command workflow

Add `github-mode-command.yml` to handle `explain`, `refactor`, `test`, `diagram`.

Execution policy:

- parse command source (issue/PR comment or workflow dispatch)
- evaluate actor trust + context trust
- route to safe adapter set based on trust level.

### Step 4.2 - Implement constrained agent-run workflow

Add `github-mode-agent-run.yml`:

- run core orchestration path with GitHub adapters
- enforce tool-policy contracts from `runtime/github/command-policy.json`
- post signed, traceable summary outputs.

### Step 4.3 - Implement bot PR workflow

Add `github-mode-bot-pr.yml`:

- create branch outputs for approved commands
- open PRs with provenance metadata (input command, commit SHA, policy version)
- ensure no direct writes to protected branches.

### Step 4.4 - Implement cross-entity collaboration workflows

Add:

- `github-mode-collab-dispatch.yml`
- `github-mode-collab-receive.yml`

Requirements:

- support policy-checked cross-repo collaboration via `repository_dispatch`
- support reusable orchestration via `workflow_call` where trusted and version-pinned
- enforce collaboration envelope validation (entity ids, intent, correlation id, source run id, policy version, ttl)
- persist collaboration traces to artifacts and markdown summaries for auditability.

---

## Phase 5 - Promotion, Attestation, and Incident Operations

### Step 5.1 - Implement promotion workflows

Add:

- `github-mode-promote-dev.yml`
- `github-mode-promote-staging.yml`
- `github-mode-promote-prod.yml`

Requirements:

- environment protections and approvals required
- promotion blocked unless validation/eval/cost/policy checks are green
- immutable artifact references in promotion records.

### Step 5.2 - Implement attestation generation and verification

- Generate attestations in `attestations/` containing required fields:
  - commit/environment/policy/routing/agent revisions
  - model IDs, dataset hashes, eval summary, budget caps, approvers, timestamp
- Add verification step to confirm attestation completeness and tamper-evidence.

### Step 5.3 - Implement drift and incident workflows

Add:

- `github-mode-drift.yml`
- `github-mode-incident.yml`

Requirements:

- scheduled drift checks over policy/routes/evals/cost envelopes
- auto-create issues with severity labels and evidence links
- optional escalation to promotion lock when severe drift detected.

### Step 5.4 - Add collaboration incident handling

- Detect and alert on:
  - unauthorized source entity
  - blocked intent/channel attempts
  - replayed or expired collaboration envelopes
  - repeated delivery failures to peer entities
- Auto-create/append incident issues with correlation ids and workflow evidence links.

---

## Phase 6 - Adapter and Emulation Expansion

### Step 6.1 - Build adapter library for GitHub-safe tools

- Implement adapters for:
  - filesystem patch planning
  - docs generation
  - route simulation
  - replayed inbound event streams
- Keep adapters explicitly separate from installed-only tooling.

### Step 6.2 - Build emulation harnesses

- Add replay/mocks for channel events and memory stores.
- Define fidelity score per emulated subsystem.
- Feed outcomes into parity matrix updates.

### Step 6.3 - Shrink installed-only surface deliberately

- Identify installed-only capabilities that can move to `adapter` or `emulated`.
- Require threat-model + parity + test updates for each migration.

---

## Phase 7 - Observability, Compliance, and Ongoing Governance

### Step 7.1 - Add runtime observability

- Standardize workflow summary and artifact schemas.
- Emit metrics for:
  - parity coverage
  - workflow success/flakiness
  - bot PR throughput
  - cross-entity collaboration success/failure rate
  - collaboration latency and retry rates
  - policy violation frequency
  - promotion lead/rollback time.

### Step 7.2 - Add compliance checks for security controls

Create mandatory checks that fail when:

- workflow permissions are over-broad
- third-party actions are not SHA-pinned
- protected workflows expose secrets in untrusted triggers
- environment-protected promotions are bypassed.

### Step 7.3 - Define rotation and incident playbooks

- Add operational runbooks for:
  - API key/secret rotation (GitHub Secrets + Environment Secrets)
  - emergency secret revocation
  - compromised workflow token response
  - attestation audit and rollback process.

---

## Security Requirements Checklist (must be true before rollout)

1. All API keys managed through GitHub Secrets/Environment Secrets only.
2. No secrets available to fork PR workflows.
3. All privileged workflows require trusted actor and/or environment approval.
4. All third-party actions pinned by commit SHA.
5. `GITHUB_TOKEN` permissions explicitly least-privilege per workflow/job.
6. OIDC used instead of long-lived cloud credentials where possible.
7. Protected branches cannot be written directly by GitHub mode bots.
8. Promotion requires successful gates + recorded attestation.
9. Logs/artifacts are scrubbed to prevent secret leakage.
10. Security lint checks enforce the above continuously.

---

## Delivery Milestones

- **M1:** Contract scaffolding + parity matrix + threat model + baseline tests
- **M2:** Security foundation complete (secrets/environments/permissions/OIDC/action pinning)
- **M3:** Validation/policy/route/eval/cost workflows live
- **M4:** Command + agent-run + bot PR + collaboration dispatch/receive workflows live
- **M5:** Promotion + attestation + drift/incident + collaboration incident workflows live
- **M6:** Expanded adapters/emulation + parity + collaboration score reporting

---

## Definition of Done for Implementation

GitHub Mode is considered implemented when:

1. Installed runtime behavior remains unchanged under baseline regression checks.
2. GitHub Runtime Plane executes high-value orchestration/eval/policy workflows using shared core paths.
3. Security is fully managed through normal GitHub controls (Secrets, Environments, approvals, permissions, OIDC, branch protection, SHA-pinned actions).
4. Promotion and incident handling are approval-gated and backed by attestations.
5. Parity matrix is maintained and shows measurable progress over time.
6. Users can template and configure multiple OpenClaw entity repos in their GitHub account, and those entities can collaborate through policy-governed GitHub-native channels.
