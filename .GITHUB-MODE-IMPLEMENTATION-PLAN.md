# OpenClaw GitHub Mode Implementation Plan

This plan operationalizes `.GITHUB-MODE.md` into phased execution with clear deliverables, gates, and rollback safety.

---

## 1) Program Objectives

1. Deliver a high-functionality GitHub Runtime Plane without regressing installed OpenClaw runtime behavior.
2. Reuse core orchestration/agent/tool-policy paths before introducing adapters.
3. Enforce security through standard GitHub controls (Secrets, Environments, branch protections, approvals, least privilege, OIDC, SHA-pinned actions).
4. Establish measurable functional parity using a maintained parity matrix.
5. Enable safe multi-entity template bootstrap and policy-governed cross-entity collaboration.

---

## 2) Non-Negotiable Guardrails

- Installed runtime behavior must remain unchanged unless explicitly approved by maintainers.
- GitHub mode must never require custom in-repo secret vaulting.
- No privileged workflow execution from untrusted actors/contexts.
- All third-party actions must be pinned to full commit SHA.
- All privileged branch mutations must occur via PR workflow, never direct writes to protected branches.

---

## 3) Workstreams

- **WS-A: Runtime contracts and parity**
- **WS-B: GitHub security foundation**
- **WS-C: Validation/policy/eval/cost workflows**
- **WS-D: Command runtime and bot PR loop**
- **WS-E: Promotion, attestation, and incident operations**
- **WS-F: Multi-entity template and collaboration**
- **WS-G: Observability, compliance, and governance**

---

## 4) Phase-by-Phase Plan

### Phase 0 - Baseline and design locks

### Deliverables

- ADR(s) for installed vs GitHub runtime boundaries.
- Installed runtime regression baseline definition and smoke checks.
- GitHub runtime threat model (trusted/untrusted trigger matrix, abuse cases, mapped controls).

### Task 0 acceptance lock (must all be true before Phase 1)

- **Task 0.1 - Runtime Boundary ADR Package**
  - ADR set is approved by maintainers.
  - Boundaries define ownership, allowed shared modules, and prohibited coupling patterns.
  - Backout trigger (`runtime coupling detected`) is documented and linked in review workflow.
- **Task 0.2 - Installed Runtime Regression Baseline**
  - Baseline smoke checks run in CI and are green on mainline.
  - Baseline failures block merges for GitHub-mode-touching changes.
- **Task 0.3 - GitHub Threat Model + Trigger Matrix**
  - Matrix covers fork PR, internal PR, push, schedule, and manual dispatch.
  - Every abuse case maps to at least one preventive or detective control.
  - Threat model explicitly forbids privileged execution in untrusted contexts and privileged branch mutation outside PR flow.

### Task 0 acceptance evidence snapshot

Status: ✅ Locked and satisfied (2026-02-16).

- ✅ **Task 0.1 evidence captured**
  - ADR package approved in `docs/github-mode/adr/0001-runtime-boundary-and-ownership.md` and `docs/github-mode/adr/0002-installed-runtime-non-regression-guardrails.md`.
  - ADR index records gate status in `docs/github-mode/adr/README.md`.
- ✅ **Task 0.2 evidence captured**
  - Installed-runtime non-regression policy and backout trigger (`runtime coupling detected`) documented in `docs/github-mode/adr/0002-installed-runtime-non-regression-guardrails.md`.
  - CI baseline hooks live in existing install smoke workflows (`.github/workflows/install-smoke.yml` and `.github/workflows/sandbox-common-smoke.yml`) and provide the installed-runtime smoke baseline foundation referenced by Task 0.
- ✅ **Task 0.3 evidence captured**
  - Trigger trust matrix and abuse/control mapping approved in `docs/github-mode/security/0001-github-trigger-trust-matrix.md`.
  - Security index records gate status in `docs/github-mode/security/README.md`.

Phase 1 is authorized to proceed only while this evidence remains valid and approvals remain current.

### Exit criteria

- Maintainers approve ADR + threat model.
- Baseline checks are runnable and green in CI.

### Backout strategy

- If parity work causes runtime coupling, revert to boundary ADR and block merge.

---

### Phase 1 - Contract scaffolding and parity framework

### Deliverables

Create `runtime/github/` core contracts and schemas:

- `manifest.schema.json`
- `runtime-manifest.json`
- `adapter-contracts.json`
- `command-policy.json`
- `trust-levels.json`
- `entity-manifest.schema.json`
- `collaboration-policy.schema.json`
- `collaboration-envelope.schema.json`
- `workspace-convergence-map.json`
- `parity-matrix.json`

Add validators:

- schema validation for all runtime contracts
- parity matrix validator requiring owners + rationale for `installed-only`
- convergence map validator that fails on unmapped high-value installed workflows

### Exit criteria

- Contract validation check is mandatory in CI.
- Parity report artifact generated per PR for changed subsystems.

### Backout strategy

- Contract schema changes are versioned; incompatible changes require migration notes and compatibility validator updates.

---

### Phase 2 - Security foundation (GitHub-native)

### Deliverables

- Secret inventory and rotation policy document.
- Environments: `github-mode-dev`, `github-mode-staging`, `github-mode-prod` with required reviewers and branch/tag restrictions.
- Explicit least-privilege `permissions:` in every GitHub-mode workflow/job.
- OIDC integration for cloud access where applicable.
- Lint check that fails on:
  - unpinned third-party actions
  - over-broad workflow permissions
  - secrets exposed in untrusted triggers

### Exit criteria

- Security lint passes across all GitHub-mode workflows.
- No secrets accessible in fork PR contexts (verified by tests/simulation).
- Environment approvals enforce promotion paths.

### Backout strategy

- Any security control regression blocks release; revert offending workflow changes.

---

### Phase 3 - Core validation, simulation, eval, and cost workflows

### Deliverables

Implement:

- `github-mode-build.yml`
- `github-mode-check.yml`
- `github-mode-test.yml`
- `github-mode-policy.yml`
- `github-mode-route-sim.yml`
- `github-mode-eval-tier0.yml`
- `github-mode-cost.yml`
- `github-mode-sync-templates.yml`

Required behavior:

- deterministic artifacts + markdown summaries
- untrusted-safe behavior for fork PRs
- policy/route drift detection
- threshold gates for eval/cost
- template drift detection with migration guidance or PR output

### Exit criteria

- Required checks gating merges are active.
- Failing policy/eval/cost thresholds block promotion workflows.

### Backout strategy

- If flakiness exceeds tolerance, downgrade workflow from required to informational temporarily and open reliability incident.

---

### Phase 4 - Command runtime and bot PR loop

### Deliverables

Implement:

- `github-mode-command.yml`
- `github-mode-agent-run.yml`
- `github-mode-bot-pr.yml`

Command support baseline:

- `explain`
- `refactor`
- `test`
- `diagram`

Required behavior:

- trust-aware command authorization
- policy-gated adapter invocation
- provenance metadata embedded in outputs (source command, commit SHA, run id, policy version)
- no direct writes to protected branches

### Exit criteria

- Trusted users can trigger command-to-PR flow end-to-end.
- Untrusted users cannot invoke privileged adapters or secret-backed paths.

### Backout strategy

- If command abuse is detected, disable privileged command handlers and keep read-only explain flows.

---

### Phase 5 - Promotion, attestation, and incident operations

### Deliverables

Implement:

- `github-mode-promote-dev.yml`
- `github-mode-promote-staging.yml`
- `github-mode-promote-prod.yml`
- `github-mode-drift.yml`
- `github-mode-incident.yml`

Add attestation generation + verification with required fields:

- commit/environment
- policy/routing/agent revisions
- model ids + dataset hashes
- eval/cost results
- approvers + UTC timestamp
- artifact/run references

### Exit criteria

- Promotions require green gates + environment approval + valid attestation.
- Drift and incident workflows create evidence-linked issues automatically.

### Backout strategy

- If attestation verification fails, promotion remains blocked and incident issue is auto-created.

---

### Phase 6 - Multi-entity bootstrap and collaboration

### Deliverables

Implement:

- `github-mode-bootstrap-entity.yml`
- `github-mode-collab-dispatch.yml`
- `github-mode-collab-receive.yml`

Add entity template baseline validator for:

- labels
- issue forms
- PR templates
- CODEOWNERS
- environment placeholders
- branch protection expectations

Collaboration requirements:

- enforce collaboration policy routes (deny-by-default)
- validate envelope fields (source/target entity, intent, correlation id, run id, policy version, ttl)
- audit traces via artifacts + workflow summaries

### Exit criteria

- Two template-generated entities can collaborate on allowlisted intents.
- Blocked/untrusted intents are rejected with auditable evidence.

### Backout strategy

- On repeated collaboration failures or abuse, disable dispatch permissions and leave receive validation in monitor-only mode.

---

### Phase 7 - Observability, compliance, and program handoff

### Deliverables

- Standardized artifact schemas and summary format.
- Metrics pipeline for:
  - parity coverage trend
  - workflow reliability/flakiness
  - bot PR throughput + acceptance
  - collaboration success/failure + latency
  - policy/security violation rates
  - promotion lead/rollback time
- Operational playbooks:
  - secret/API key rotation
  - emergency revocation
  - compromised token response
  - attestation audit + rollback

### Exit criteria

- Dashboards/reports available to maintainers.
- Governance playbooks reviewed and linked in docs.

### Backout strategy

- If telemetry quality is low, keep gating on hard checks while metrics instrumentation is repaired.

---

## 5) Test and Verification Strategy

Each phase must include:

- unit tests for new parser/validator/policy logic
- integration tests for workflow decision boundaries
- replay tests for emulated adapters where applicable
- regression checks proving installed runtime behavior remains unchanged

Minimum pre-merge gate for GitHub-mode codepaths:

1. contracts/parity validation
2. security lint (permissions, pinning, trigger safety)
3. policy/route checks
4. eval + cost threshold checks (for impacted subsystems)

---

## 6) Security Acceptance Checklist

All must be true before broad rollout:

1. Secrets are managed only via GitHub Secrets/Environment Secrets.
2. Fork PR workflows have zero secret access.
3. Privileged workflows require trusted actor and/or environment approval.
4. Third-party actions are SHA-pinned.
5. `GITHUB_TOKEN` permissions are explicit and minimal.
6. OIDC replaces static cloud credentials where possible.
7. Bots cannot write directly to protected branches.
8. Promotion requires successful checks and valid attestation.
9. Logs/artifacts are scrubbed for secret leakage risk.
10. Compliance checks enforce these controls continuously.

---

## 7) Milestones

- **M1:** Phase 0-1 complete (contracts + parity + threat model + baseline checks)
- **M2:** Phase 2 complete (security foundation)
- **M3:** Phase 3 complete (validation/policy/eval/cost/template drift workflows)
- **M4:** Phase 4 complete (command + agent-run + bot PR)
- **M5:** Phase 5 complete (promotion + attestation + drift/incident)
- **M6:** Phase 6 complete (multi-entity bootstrap/collaboration)
- **M7:** Phase 7 complete (observability + compliance + governance handoff)

---

## 8) Definition of Done

GitHub mode implementation is complete when:

1. Installed runtime remains behaviorally stable under regression checks.
2. High-value OpenClaw orchestration/policy/eval paths run in GitHub mode using shared core modules.
3. Security controls are fully GitHub-native and continuously enforced.
4. Command-to-PR automation is policy-governed, auditable, and safe by default.
5. Promotions are approval-gated with verified attestations.
6. Parity matrix is maintained and improving over time.
7. Template-generated entities can collaborate through validated, deny-by-default GitHub-native channels.
